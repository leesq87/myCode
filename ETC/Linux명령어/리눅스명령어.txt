간단 명령어 

addbib  - 도서목록형식의데이터베이스를 만들거나, 확장 
apropos  - 사용설명서의 키워드 검색 
ar       -  라이브러리 만들기, 관리 
at, batch -원하는시간에 원하는명령을 실해하게하는명령 
awk     - 패턴 검색과 언어 처리 
banner   - 큰 글자(배너) 만들기 
basename - 경로 이름에서 마지막에 있는 이름만 출력 
biff     - 자신에게 편지가 배달되면 알려주는 명령 
bin-mail, binmail - 예전에 사용한 전자우편 프로그램 
cal     - 달력보기 
calendar - 간단한 일정표 
cat    - 파일 병합과 내용 보기 
cb     - 간단한 C 프로그램 beautifier
cc     - C 컴파일러 
cd    - 작업 디렉토리 바꾸기 
checknr -nroff또는troff 입력 파일 검사,오류를 보여준다 
chgrp  - 파일의 사용자 그룹 바꾸기 
chmod - 파일의 접근 권한 바꾸기 
clear  - 터미날 화면 깨끗이 하기 
cmp   - 두 파일을 바이트 단위로 비교 
colcrt  - troff 파일의 밑줄 속성 문자 처리 
comm  - 지정 두파일의 줄 단위 비교와 그 처리 
compress, uncompress, zcat - 파일압축관련유틸리티들 
cp     - 파일 복사 
cpio   - copy file archives in and out 
cpp    - C 언어 전처리기 
csh - C문법과 비슷한 쉘스크립트문법과 여러 기능이 내장된 쉘 
ctags  - ex 나 vi 편집기에서 사용될 tag 파일을 만드는 명령 
date    - 시스템 시간 보기나 지정하기 
dbx    - 소스 수준의 디버거 
deroff  - nroff, troff, tbl, eqn 관련 내용 지움 
df     - disk free: 디스크의 남은 용량 보기 
diff    - 두 파일의 차이점 비교 
du     - disk used : 디스크 사용량 보기 
echo   - 인자를 표준 출력으로 출력 
ed, red - 기본 줄 편집기 
eqn, neqn, checkeq - 수식 표현 포멧 도구 
error   - 컴파일러 오류 메시지 목록 
ex, edit, e - 줄 편집기 
expand, unexpand - TAB 문자를 공백문자로 바꿈, 또는 그반대로 
expr    - 인자를 수식으로 처리 
file     - 파일 형식 알아보기 
find    - 파일 찾기 
finger   - 사용자 정보 알아보기 
fmt, fmt_mail - 간단한 문서나, 편지 포멧 도구 
fold    - 긴 줄 출력 방법 지정 
ftp     - 파일 전송 프로그램 
gcore   - 실행 중인 프로세스의 core 이미지를 구한다. 
gprof   - call-graph profile data(?)를 보여줌 
grep   - 문자열 찾기 
groups - 사용자의 그룹을 보여줌 
history - 이전 명령 보기 
hostname - 현재 시스템 이름을 보여줌 
imake   - makefile 만드는 프로그램 
indent  - C 프로그램 소스 파일을 들여쓰기 하는 포멧 도구 
install  - 파일 설치 
join    - 관계형 데이터베이스 연산자 
kill - 프로세스  stop :-) 
last     - 사용자가 마지막 접속 상태를 보여줌 
ld, ld.so - 링크 편집기, 동적 링크 편집기 
leave    - 자신의 접속 종료 시간을 알려줌 
less     - more 명령의 확장 
lex     - 어휘 분석 프로그램 생성기 
lint     - C 프로그램 verifier 
ln      - 파일의 하드, 심벌릭 링크 명령 
login   - 시스템 접속 명령 
look    - 시스템 디렉토리나, 정열된 목록에서 단어 찾기 
lookbib - 도서목록형 데이타베이스에서 찾기 
lorder  - 오브젝트 라이브러리의 관계 찾기 
lp, cancel - 인쇄 시작, 취소 
lpq     - 인쇄 작업 상황 보기 
lpr     - 인쇄 
lprm   - 인쇄 작업 지우기 
ls      - 디렉토리 내용 보기 
mail, Mail - 전자 우편 프로그램 
make - 실행파일을만들거나, 특정 파일을 만들 때 사용하는 도구 
man    - 온라인 사용자 설명서를 보는 명령 
mesg   - 메시지 수신 상태를 보거나 지정 
mkdir   - 디렉토리 만들기 
mkstr   - C 소스 파일을 참조로 오류 메시지 파일을 만듬. 
more, page - 텍스트 파일 보기 명령 
mv     - 파일 이동이나, 이름 바꾸기 
nawk   - 패턴 검색과 언어 처리 
nice    - 낮은 우선권에서 명령 실행 
nm     -  심블 이름 목록 보기 
nroff   - 문서 포멧 도구 
od     - 8진수, 10진수, 16진수, ascii 덤프 
passwd, chfn, chsh - 비밀번호, 핑거정보, 쉘 바꾸기 
paste   - 여러파일의 서로 관련 있는 줄 연결시키기 
pr      - 문서 파일 양식화 도구 
printenv - 현재 환경 변수들의 내용과 그 값 알아보기 
prof     - profile 자료 보기 
ps      - 현재 프로세스 정보 보기 
ptx     - permuted(순열화된?, 교환된?) 색인 만들기 
pwd     - 현재 작업 디렉토리 보기 
quota   - 한 사용자에게 지정된 디스크 할당량보기 
ranlib   - archive를 random 라이브러리로 변화 
rcp     - 리모트 카피 
rcs     - RCS 파일 속성 바꾸기 
rcsdiff  - RCS revisions 비교 
rev     - 한 줄의 문자열 꺼꾸로 
rlogin   - 리모트 로그인 
rm, rmdir - 파일, 디렉토리 지우기 
roffbib   - 도서목록형 데이터베이스 보기 또는 양식화 
rsh     - 리모트 쉘 
rup     - 로칼 머쉰의 호스트 상태 보기(RPC version) 
ruptime - 로칼 머쉰의 호스트 상태 보기 
rusers   - 현재 접속자 보기 (RPC version) 
rwall   - 모든 사용자에게 알림(RPC) 
rwho    - 현재 접속자 보기 
sccs    - Source Code Control System (SCCS) 
sccs-admin, admin-SCCS 사용 내역 파일을 만들고, 관리 
sccs-cdc, cdc      - SCCS 델타의 델파 주석을 바꿈 
sccs-comb, comb    - SCCS 델타 조합 
sccs-delta, delta   - SCCS 파일에 데해 델타를 만듬 
sccs-get, get        - SCCS 파일 버전확인 
sccs-help, help    - SCCS 오류나 경고 메시지 검색 
sccs-prs, prs   - SCCS 사용내역의 선택된 부분 보기 
sccs-prt, prt - SCCS 파일에서 델타 테이블 정보를 봄 
sccs-rmdel, rmdel   - SCCS 파일에서 델타를 지움 
sccs-sact, sact      - SCCS 파일의 편집 상태를 봄 
sccs-sccsdiff, sccsdiff - SCCS 파일들의 버전 비교 
sccs-unget, unget   - SCCS 파일의 얻은 것을 취소
sccs-val, val       - SCCS 파일 유요화 
script     - 화면 갈무리 
sed       - stream editor 
sh        - 유닉스 표준 쉘 
size       - 오브젝트 파일의 크기들을 보여줌 
sleep     - 지정한 시간 만큼 실행 보류 
sort      - 줄 정열과 검색 
sortbib    - 도서목록형 데이터베이스 정열 
spell, hashmake, spellin, hashcheck - 맞춤범 검사
split      - 파일 나누기 
strings   - 오브젝트 파일, 실행 파일에서 문자열 찾기 
strip     - 오브젝트 파일에서 심벌 테이블과 중복된 비트 삭제 
stty     - 터미날 설정 
su      - super-user, 임시적으로 새 ID로 바꿈 
symorder - 심벌 순서 바꿈 
tabs    - 터미날 tab 크기 지정 
tail     - 파일의 끝 부분 보기 
talk    - 다른 사용자와 이야기하기 
tar     - 여러 파일 묶기 또는 묶긴 파일 풀기 
tbl     - nroff 또는 troff의 도표 작성 도구 
tee      - 표준 출력으로 방향 전환 
telnet   - TELNET 프로토콜을 이용한 원격 리모트 호스트 접속 
test     - 주워진 환경이 참인지, 거짓인지를 돌려줌 
tftp     - 간단한 ftp. 
time     - 명령 실행 시간 계산 
touch    - 파일 날짜 관련 부분을 바꿈 
troff     - 문서 양식화 도구 
true, false - 쉘 에서 사용되는 참/거짓을 리턴하는 명령 
tsort    - topological sort 
tty     - 현재 터미날 이름 보기 
ue      - MICROemacs 
ul      - 밑줄 속성 문자 표현 
unifdef - cpp 입력 줄에서 ifdef 부분 바꾸거나 지움 
uniq   - 중복되는 빈줄 지우기 
units   - 프로그램 변환도구 
uptime  - 시스템 부팅 기간 보기 
users   - 현재 접속 사용자 보기 
uucp, uulog, uuname - 시스템 간의 복사 
uuencode, uudecode - 이진파일을 아스키파일로 인코딩,반대로 디코딩 
uusend   - 리모트 호스트에 파일 보내기 
uux     - 리모트 시스템 명령 실행 
vacation  - 자동으로 편지 답장하기 
vgrind   - grind nice program listings 
vi, view, vedit - ex 바탕의 편집기 
vtroff    - 문서 양식화 도구 
w       - 현재 누가 접속해 있으며, 무엇을 하고있는지 
wait     - 프로세스가 마치기를 기다림 
wall      - 모든 사용자에게 알림 
wc       - 단어, 줄, 바이트 계산 
what    - 파일에서 SCCS 버전 정보 알아냄 
whatis   - 명령의 간단한 설명 보여줌 
whereis - 찾는 명령의 실행파일, 소스, 맨페이지가 어디 있는지 경로를 보여 줌 
which    - 명령만 찾음. 
who     - 시스템에 접속되어 있는 사람만 보여줌 
whoami - 현재 사용하고 있는 자신이 누군지 보여줌 
write   - 다른 사용자의 화면에 특정 내용을 알림 
xargs   - 명령행 인자 처리 명령 
zcat     - 압축 파일 내용보기








상세 명령어

adduser
 루트로 로그인해서 이용자를 추가
 $ adduser [ID]

admin
SCCS(Source code control system)파일을 작성관리를 위한
$ admin [-nirtfdaemyhz] files 
-n  : 신규 SCCS 화일을 작성 
-i[name] : 신규 SCCS 화일에 등록된 화일명(name) 
-f  : flag SCCS 화일에 등록하는 플래그들의 값을 지정 
-r  : 번호 초기 델타의 릴리즈 번호 지정은 -i와 함께 사용 
-t[name] : SCCS 화일의 주석문으로 등록되는 화일명(name) 
-e  : login 델타 작성 가능한 사용자 리스트로 부터 삭제되는 로그인명 
-h  : 신규 check sum을 계산하고 기존 check sum과 비교 
-z  : check sum을 계산하여 SCCS 화일에 기록 

alias
자주 쓰이는 명령어를 쓰기 편하게 바꾸는 명령
$ alias [새로만들 명령어]='[기존 명령어] [옵션]'
$ alias cp='cp -i'
$ alias la='ls $LS_OPTIONS -a'
$ alias less='less -rf'
$ alias lf='ls $LS_OPTIONS -F'
$ alias ll='ls $LS_OPTIONS -l'
$ alias ls='ls $LS_OPTIONS'
$ alias mv='mv -i'
$ alias rm='rm -i'
$ alias dir='ls -al

ar
아카이브 화일에 있는 화일의 그룹들을 유지 관리하는 명령어 
$ ar [-X32_64] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file... 
$ ar -M [<mri-script] 
d  : delete file(s) from the archive
m[ab] : move file(s) in the archive
p  : print file(s) found in the archive
q[f]  : quick append file(s) to the archive
r[ab][f][u] : replace existing or insert new file(s) into the archive
t  : display contents of archive
x[o]  : extract file(s) from the archive
command specific modifiers:
[a]  : put file(s) after [member-name]
[b]  : put file(s) before [member-name] (same as [i])
[N]  : use instance [count] of name
[f]  : truncate inserted file names
[P]  : use full path names when matching
[o]  : preserve original dates
[u]  :only replace files that are newer than current archive contents
generic modifiers:
[c]  : do not warn if the library had to be created
[s]  : create an archive index (cf. ranlib)
[S]  : do not build a symbol table
[v]  : be verbose
[V]  : display the version number
[-X32_64] : (ignored)

at
프로그램을 지금이 아닌 나중에 실행하도록 예약한다.
$ at [option]
-q 큐  : 대소문자 알파벳으로 큐를 지정한다. 순서적으로 빠른 알파벳이 지정된 큐 일수록 CPU 시간 점유 우선권이 낮다.
-r 작업번호 : 큐에서 작업 번호가 지시하는 작업을 지운다. 슈퍼유저가 아니라면 자신의 작업만을 지울 수 있다.
-l  : 현재 계획된 작업들의 목록을 보여준다. 슈퍼 유저라면 모든 작업들의 계획목록을 보여준다.
-m  : 작업이 완결되면 사용자에게 메일을 보낸다.
-f filename:표준 입력이 아닌 지시된 파일에서 작업을 읽어온다.
  ps- 수행 시간 지정 명령어 -->at 11:30 pm 

awk
program file에서 기술된 pattern들 중 일치되는 line 을 찾기 위해 입력 화일을 검색하는 명령어 
$ awk [-Fc] [profile] [file] ...
$ awk [-Fc] [-f profile] [file] ...
-Fc  : 입력필드의 구분기호로서 c를 이용 
-f  : progam file로서 다음 인수 사용 

background : 하나의 명령을 수행시킨후 그 수행의 종료 이전에 다른 명령을 수행 하는 것 
      명령어 끝에 &로 표시 (cc -o test1 test1.c &) 

banner
인수로 주어진 문자열을 큰 글씨로 만들어서 출력
$ banner [ -w [숫자] ] 문자열
-w  : 옵션 지정만 하면 80 칼럼으로 폭을 바꾼다. 지정하지 않으면 132 칼럼으로 내정되어 있다. -w 옵션 뒤에 숫자를 지정하면 원하는 폭으로 조정할 수 있다.

bang
＇!＇ 문자를 부르는 말로, C shell에서 ＇!!＇를 명령어 라인에 입력하면, 마지막 명령을 반복하며, Bang!Bang!(뱅뱅)이라고 부른다. 

bash
bash 셸이 아닌 사용자가 셸을 변경하고자 할 때 사용하는 명령입니다.
bash셸은 일반적으로 Linux의 기본 셸로 지정되어 있습니다.
만약 다른 셸을 사용하고 있으면서 bash 셸로 바꾸기 위한 명령은 다음과 같습니다.
# bash     (enter)'

bc
C Language와 유사한 대화식 번역기이며 무제한 정도의 연산을 제공하는 명령어
$ bc [-cl] [file ... ] 
-c  : compile만 한다 
-l  : 임의 정밀도의 수학 library명을 의미 

bg %1( " ) : 포그라운드로 " " 백그라운드로 전환 
biff
전자우편의 수신을 즉시 알려주는 동작을 가능하게 할 것인지 그렇지 않은 지의 여부를 보여주거나 결정
$ biff [ y 혹은 n]
유닉스 셸은 사용중이라도 주기적으로 전자우편의 수신 여부를 점검한다. 만일 사용자가 전자우편이 도착하는 즉시 알고자 한다면 biff를 사용하여 그것을 지시할 수 있다. 또는 언제라도 그 기능을 해제할 수도 있다. biff는 인수없이 사용되면 현재 어떤 상태로 되어 있는지 보여준다. 기능 설정과 해제 여부는 y 혹은 n 인수를 주어서 결정한다.

bzip2
자료를 압축하기 위한 새로운 알고리즘이다. 보통은 gzip으로 한 것의 60-70%의 크기로 압축한다. 
bzip2는 압축률과 복원률에서 탁월한 성능을 자랑하고 있다. 또한 UNIX 및 WIN32에서 모두 사용할 수 있으며 프로그램은 GNU을 따르므로 누구든지 사용할 수 있다.

cal
서기 원년부터 9999년까지의 달력을 볼 수 있다 .
$ cal [-jy] [ [ 달 ] 연도 ]
-j  : 1월 1일부터 날짜수를 계산하는 julian 날짜를 표시한다.
-y  : 올해의 달력을 표시한다.
  cal 9 1995 : unix 시스템에 내장되어있는 달력을 화면에 출력 

cancel [print name] ; 프린터 취소

cat
파일의 내용을 표준 출력으로 내보내어, 파일내용을 알아보거나, 여러 파일을 하나의 파일로 출력하여 연결합니다. 또는 표준 입력으로부터 파일을 만들 수도 있습니다.
$ cat [option] file_name(s)
-b  : 공백 외의 글자가 있는 모든 행의 개수를 센다.
-e  : 제어 문자를 ^ 형태로 출력하면서, 각 행의 끝에 $를 추가한다. -vE와 같다.
-n  : 각 행을 출력하면서 행 번호를 함께 첨부한다.
-s  : 중복되고 겹치는 빈 행은 하나의 빈 행으로 처리한다.
-r  : 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력한다. -vT와 같다.
-u  : 유닉스 호환성을 위해 추가된 옵션으로서 무시된다.
-v  : tab과 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력한다.
-E  : 각 행마다 끝에 $ 문자를 출력한다.
-T  : 시로서 탭(tab) 문자를 출력한다.
-A  : -vET 옵션을 사용한 것과 같은 효과를 가진다. 

cat address.list : 파일의 내용을 화면에 출력한다 

cat : 파일을 작성하거나 파일의 내용을 간단하게 출력 
   # cat test1.c 
   # cat > test1.c 

cc
C Language를 compile 하는 compiler
$ cc [option] file 
-c  : compile의 linkage editor 단계를 억제한다 
-E  : 지정된 C program에 대해 cpp만을 실행하고 결과는 표준출력하지 않는다 
-f  : C program에서 부동소수점을 포함하는 코드를 linkage editor시킨다 
-o  : outfile outfile이라는 화일명으로 목적프로그램을 저장하며 생략시는 a.out에 저장 
-s  : C program을 compile 하지만 assemble하지 않으며 어셈블리 언어 출력은 .S가 붙은 화일에 저장 
cc test.c 
 -옵션 -r: 이전에 지정된 작업 취소, -l : 지정된 작업 번호 출력 
  (sleep 20; cc -o sample sample.c)& -->백그라운드 실행, 20초 뒤 프로그램 컴파일 
  (sleep 10; ps -el) --> 10초후 모든 프로세서 상태 출력 
  time cc -o test test.c --수행 시간 출력 명령어 

cd
디렉토리를 변경 
$ cd [directory]
$ cd cgi-bin : 하부 디렉토리인 cgi-bin으로 들어감. 
$ cd .. : 상위디렉토리로 이동 
$ cd or cd ~ : 어느곳에서든지 자기 홈디렉토리로 바로 이동 
$ cd /webker : 현재 작업중인 디렉토리의 하위나 상위 디렉토리가 아닌 다른 디렉토리(webker)로 이동하려면 /로 시작해서 경로이름을 입력하면 된다. 

chfn
사용자의 finger 정보를 바꾸는 명령어입니다. 
 
chgrp
파일의 그룹 소유권을 바꾼다.
$ chgrp [option] 그룹_파일들
-c  : 실제로 소유자가 바뀐 파일에 대해서 자세히 기술한다.
-f  : 파일의 그룹 소유권을 바꿀 수 없더라도 에러 메시지를 출력하지 않는다.
-v  : 소유권의 바뀜에 대해서 자세히 기술한다.
-R  : 디렉토리와 그 내용 파일들의 소유권을 재귀적으로 모두 바꾼다.

chmod
화일 permission 제어
$ chmod [option] [file]
$ chmod [option] 레벨 동작 권한 파일이름(들)
-c  : 실제로 파일의 권한이 바뀐 파일만 자세히 기술한다.
-f  : 파일의 권한이 바뀔 수 없어도 에러 메시지를 출력하지 않
-v  : 변경된 권한에 대해서 자세히 기술한다.
-R  : 디렉토리와 파일들의 권한을 재귀적으로 모두 바꾼다.
참고
예) -rwxr-xr-x guestbookt.html 
rwx : 처음 3개 문자 = 사용자 자신의 사용 권한 
r-x : 그다음 3개 문자 = 그룹 사용자의 사용 권한 
r-x : 마지막 3개 문자 = 전체 사용자의 사용 권한 
읽기(read)---------- 화일 읽기 권한 
쓰기(write)---------- 화일 쓰기 권한 
실행(execution)------ 화일 실행 권한 
없음(-)------------ 사용권한 없음 

chmod --- 파일 및 디렉토리에 이미 정해진 접근 허가 모드를 변경 
  - 사용 형식: %chmod [ugoa] [+-=] [rwx] [file name] 
  u: 파일 소유자, g: 그룹, o: 기타 사용자, a: 모든 사용자 
  +: 사용허가부여, -: 사용허가박탈, =: 허가 취소 
  r: 읽기 허가, w:쓰기 허가, x: 실행 허가 
  특정 사용자를 지정하지 않으면 모든 사용자를 의미한다 
chmod go+r test.c ; 소유자 그룹과 기타 사용자에게 읽기 허가 
chmod ugo-w test.c ; 소유자,그룹,기타 사용자에게 읽기 허가 박탈 
  chmod +x test.c 
  chmod o -rwx test.c 
  r = 4, w = 2, x =1 
  chmod 744 test.c 
  -rwxr--r-- 1 edul user 235 Oct 15 13:23 test.c 
  chmod 724 test.c 
  -rwx-w-r-- 1 edul user 235 Oct 15 13:23 test.c 

chown
파일의 소유권을 다른 사람에게로 변경시킨다.
$ chown [option] [user file]
-c  : 실제로 파일의 소유권이 바뀐 파일만 자세히 기술한다.
-f  : 파일의 소유권이 바뀔 수 없어도 에러 메시지를 출력하지 않는다.
-v  : 변경된 소유권에 대해서 자세히 기술한다.
-R  : 디렉토리와 파일들의 소유권을 재귀적으로 모두 바꾼다.
파일의 소유권을 다른 사람에게로 바꾸는 것은 슈퍼 유저만이 할 수 있다.

chsh
사용자의 shell을 바꾸는 명령어입니다. 

clear
화면 지우기

cmp
두 개의 파일 내용을 비교
$ Cmp [option] [file1] [file2]
-l  : 두 파일 내용을 비교하여 틀린 곳마다 byte수(10진수)와 틀린 byte수(8진수) 출력
-s  : 비교하여 틀린 내용을 출력하지 않고 return code 만 반환

comm               
두 개의 정렬(sort)된 화일에서 공통된 line을 선택하거나 삭제
$ comm [option] file1 file2 
-1  : file1에만 있는 line을 출력하지 않는다 
-2  : file2에만 있는 line을 출력하지 않는다 
-3  : file1, file2 양쪽 화일에 있는 line을 출력하지 않는다 

compress
확장자 .Z 형태의 압축파일 생성 
$ compress [file]  : 압축시 
$ uncompress [file]  : 해제시 
compress test.c (파일 압축) --->uncompress test.c.Z (압축 풀기)

cp
화일 복사(copy)
$ cp [option] [file1] [file2]
$ cp [option] [file1] [directory]
-a  : 가능한한 원 파일의 구조와 속성을 그대로 복사한다.
-b  : 복사할 때 덮어쓰게 되는 파일은 백업을 만든다.
-d  : 심볼릭 링크는 심볼릭 링크로 복사한다. 그리고 원본 파일과의 하드 링크 관계를 유지한다.
-f  : 복사 위치에 존재하는 파일을 제거하고 복사한다.
-i  : 복사시 같은 이름의 파일이 존재한다면 덮어쓸 것인가 확인한다.
-I  : 하드 링크를 만든다.
-P  : 원본 파일의 소유자, 그룹, 권한, 시간 기록을 그대로 복사한다.
-r  : 파일과 하위 디렉토리에 포함된 파일 모두를 재귀적으로 복사한다.
-s  : 디렉토리가 아닌 파일의 심볼릭 링크를 만든다. 소스 파일의 이름은 전체 경로 이름으로 한다. 목적지 파일 이름은 전체 경로를 주지 않아도 현재 디렉토리로 간주되므로 상관없다.
-u  : 파일의 정보를 갱신한다.
-x  : 다른 파일 시스템인 하위 디렉토리는 무시한다.
-R  : 디렉토리를 재귀적(recursive)으로 복사한다.
cp :시스템내에 있는 특정 파일을 복사 
  # mkdir temp --temp라는 디렉토리 생성 
  # cp sample test temp --temp라는 디렉토리 밑에 sample 과 test 라는 파일을 복사 
  # mkdir example 
  # cp -r temp example --temp라는 디렉토리 아래에있는 모든 내용을 example디렉토리에 복사 

cpio
아카이브 파일을 복사하여 입출력
$ cpio -o [abcv]
$ cpio -i [Bdmtuvsb] [patterns] 
$ cpio -p [adlmv] directory 
-o 복사 출력 : 화일을 path명과 정보 상태를 함께 출력 
-i  복사 입력 : 표준 입력 화일로 부터 pattern에 일치하는 화일을 추출 
-p  : *directory 내에 file 을 조건부로 작성하고 복사 
command:
a  : *file 복사후 입력 화일의 최종 접근 시간을 reset한다 
B  : 입출력을 5,120 byte의 레코드로 블럭화한다 
c  : ASCII 문자로 헤드 정보를 쓴다 
d  : 필요에 따라 directory를 생성 
m  : 존재하는 최종 화일 수정 시각을 보존 
r  : 대화 문법으로 화일명을 변경 
t  : 입력 화일명 목록을 출력하여 화일은 작성되지 않는다 
u  : 무조건 복사 
v  : 화일명 목록을 출력 

crontab
지정한 화일을 입력으로 받아 user의 크론탭 화일을 관리 및 directory로 복사하는 명령어 
$ crontab [file] 
$ crontab [-u user] file
$ crontab [-u user] { -e | -l | -r } 
-l  : crontab 파일 목록을 보여준다.
-e  : 에디터를 사용하여 crontab 파일을 수정한다.
-d  : 사용자의 crontab 파일을 지운다.
-u user : 특정 사용자의 crontab 파일을 다루도록 지정한다.
    이 명령을 사용하려면 슈퍼 유저로 로그인해야만 한다.
crontab 파일 내의 빈 핵과 # 문자로 시작되는 행은 무시된다.
파일의 각 행은 M H D m d cmd 형태로 되어 있다. 필드의 에스테리스크(*)표시는 어떠한 값이든 일치하는 조건으로 가정한다는 의미이다.
csh
유닉스 C 셸이다. 하지만 리눅스에서는 tcsh에 링크되어 있는 파일에 불과하다.

cu
다른 system을 호출
$ cu [options] [system or phone-number]
-h  : 반이중 모드만을 지원하는 시스템을 호출 
-t  : 자동응답 모드에 설정된 ASCII단말기 호출 
-d  : message 출력 
-o  : 홀수 parity 생성을 지시 
-n  : 전화번호 입력을 요구 
-l  : line 통일 회선 장치명을 지정 
-s  : speed 전송 속도(1200,2400,4800,7200,9600 bps)를 지정 

cut
파일에서 필드를 뽑아낸다. 필드는 필드 구분자나 문자 위치로 지정된다.
$ cut -c문자위치 [file1 file2]
$ cut -f필드 -d필드구분자 [-s] [file1 file2 ...] 
-c문자위치  : 잘라낼 곳의 글자 위치를 지정한다. 콤마를 사용하거나 하이픈을 사용하여 범위를 정할 수도 있으며, 이런 표현들을 혼합하여 사용할 수도 있다.
-f필드 : 잘라낼 필드를 정한다. 지정하는 방법은 -c 옵션과 같다.
-d필드 구분자: 필드를 구분하는 문자를 지정한다. 디폴트는 탭 문자다.
-s  : 필드 구분자를 포함할 수 없다면 그 행은 하지 않는다. 

date: 현재의 날짜와 시간을 화면에 표시 
  date;who;cat > sample.c : 한 줄에 두 개 이상의 명령어를 동시에 입력하고자 할 경우 명령어와 명령어 사이를 ; 으로      구분한다 
  date > date.out : 이전 내용이 지워지고 새로운 내용이 저장 
  * date >> date.out : 이전 내용과 함께 새로운 내용 첨가 

dc
system을 이용한 탁상계산기
$ dc [file] 
file  : 읽어들일 화일 지정, 생략시 표준 입력으로 간주 

dd
다양한 데이타 형식을 가진 화일을 복사, 변환
$ dd [option = value] ... 
bs=n  : 입출력 블럭의 크기를 n byte로 쓴다 
cbs=n : buffer 크기변환 
conv=ascii : EBCDIC 코드를 ASCII 코드로 변환 
conv=ebcdic : ASCII 코드를 EBCDIC 코드로 변환 
conv=lcase : 알파벳을 소문자로 변환 
conv=ibn : 약간은 다르지만 ASCII 코드를 EBCDIC 코드로 변환 
conv=noerror : 에러처리를 중지하지 않는다 
conv=swab : 두개의 byte를 서로 교환 
conv=sync : 각 입력 레코드를 ibs로 패딩 
conv=ucase : 알파벳을 대문자로 변환 
...,...  : 컴마로 구분된 여러개의 변환 
count=n : 입력코드를 n개만 복사 
files=n : 복사 시작전에 n개의 화일을 건너뛴다 
seek=n : 복사 시작전에 출력화일의 처음으로 n 레코드를 탐색 
ibs=n  : 입력블럭크기를 n byte로 한다 (디폴트는 512) 
if=file  : 입력화일명(디폴트는 표준입력) 
obs=n : 출력블럭크기를 n byte로 한다 (디폴트는 512) 
of=file : 출력화일명(디폴트는 표준출력) 
skip=n : 복사전에 입력레코드를 건너뛴다  

df
이용 가능한 디스크 블록 수 출력
$ df [-f] [-t] [file sysytem] 
-f  : 디스크내의 자유리스트내의 정확한 블럭수를 출력 
-t  : 사용가능 블럭 및 i-node와 할당된 전체블럭과 i-node가 출력 
-m  : 파일 크기를 Mbyte단위로 출력 

diff
두 개의 파일 중에서 다른 라인을 출력
$ diff [option] file1 file2 
-b  : 비교할 때 라인의 마지막에 있는 탭(tab)과 공백을 무시 
-e  : file1으로부터 file2를 재생성. ed 편집을 위한 a,c 그리고 d 명령어의 script를 만든다 
-f  : 비슷한 script를 만들지만 역순이기 때문에 ed 편집에서는 사용할 수 없다 
-h  : 정밀도가 없어도 빠른 속도를 처리하고자 할 때 사용하며 -e와 -f와 함께 사용할수 없다 
-i  : 대소문자를 구분하지 않는다.
-w  : 탭(tab) 문자를 포함한 모든 공백 문자를 무시하고 비교 작업을 수행한다.

diff3
세 개의 파일 중에서 다른 라인을 출력
$ diff3 [option] file1 file2 file3 
-e  : file1에 file2와 file3의 차이 비교를 기록 
-x  : file1에 3개 화일 모두의 차이 비교를 기록 
-3  : file1에 file3과 차이 비교되는 부분만 기록 
disable -c [print name] ; 지정한 프린터에서 현제 출력중인 작업 취소 
  * disable -w laser-3 ; 모두 인쇄한 다음 프린터를 disable 상태로 만든다 
  * disable -c -r "out of paper" laser-1 ; 주석을 달아 놓는다 

dmesg
부팅 메시지를 보여주는 명령어
Done : 백그라운드 프로세서의 수행이 완전히 종료된 상태 

du
하드 사용량 체크(chkdsk)
$ du [option][dirctory, file]
-s  : 총 합계만을 따진다. 하위 디렉토리의 숫자 등은 나오지 않는다.
-a  : 크기가 계산된 각 파일의 크기를 보인다.
-b  : 바이트 크기로 출력한다.
-x  : 현재 디렉토리에 마운트된 파일 시스템만 검사된다.
-L  : 심볼릭 링크 자신의 공간 대신 연결된 파일의 크기를 다룬다.




echo
외부 프로그램과 내부 쉘명령어 사이에 있으며 echo의 인수는 공백에 의해 구분되어지며 new line으로 종료하는 각 인수를 화면에 표준출력하는 명령어 
$ echo [option] [string]
-n  : 새로 개행하지 않고 출력하게 한다.
-e  : 문자열 중에서 백슬래쉬와 조합되는 특수 문자를 인식하게 한다. 그러한 특수 문자들은 다음과 같은 것들이 있다.
\a 밸소리    \b 백스페이스
\f 용지바꿈(form feed)  \n 행바꿈
\r 0 칼럼으로(carriage return)  \f 탭(tab)
\v  수직 탭    \\ 백슬래쉬 문자
\nnn 8진법으로 표기되는 ASCII 문자 \c 출력 후 행바꿈 금지

ed
풀 스크린 에디터를 사용할 수 없는 열악한 환경의 터미널을 위한 라인 에디터
$ ed [-] [-s] [-p문자열] [file] 
-  : e, r, w, q, ! 명령에 의해 발생하는 메시지를 금지한다.
-s  : 검사 작업을 금지한다.
-p문자열 : 프로프트를 원하는 문자열로 바꾼다.

edquota
사용자의 하드디스크 용량 및 파일의 개수를 제한한다.
$ edquota [option] [ID]
-n  : 쿼터 할당을 림트 서버에 할 수 있다.
-u  : 사용자를 정희한다. (기본값)
-p  : 사용자 그룹에 제한을 주기위한 옵션
-t  : 파일시스템의 soft time의 제한 값을 정한다. 디폴트 값은 /linux/quota.h를 따른다.

env
현재의 환경에 영향을 주지 않고 원하는 환경을 만들어 명령을 실행, 또는 현재의 환경 보고
$ env [-][-i ][-u 이름][name=value][command arg]
-  : 뒤에 오는 이름=값 목록으로 환경을 제한한다.
-i  : 현재의 환경을 무시하고 빈 환경 상태로 시작한다.
-u 이름 : 현재의 환경에 그 이름의 변수가 있다면 제거한다.
-name=value : 명령 수행 전의 원래 환경을 지정 
-command arg: 수행하고자 하는 명령어 지정 

ex
ed 기능을 강화한 텍스트 편집기
$ ex [-] [-trRV] [+command] name ... 
-  : 대화형 사용자를 위해 feed-back을 억제 
-t  : tag tag를 갖는 화일을 편집후 편집기를 그 화일의 위치에 지정 
-r  : file file을 복구 
R  : 읽기 허가만 된 모드로 한다 
+ command : 지정한 명령어를 수행하고 편집 

exit
현재의 프로세스를 종료하고 빠져나감
Exit : 백그라운드 프로세서가 수행도중 오류 때문에 빠져 나온 상태 


fdformat
플로피 디스켓을 포멧한다
$ fdformat [device]

fg
후면 작업을 전면 작업으로 전환
$ fg [%작업번호]
fg %1(작업 번호) : 백그라운드로 수행중인 작업을 포그라운드로 전환 

fgrep
문자열에 따라 파일 검색
$ fgrep [option] string [file]
-b  : 각 행의 선두에 그 행이 발견된 블럭번호를 넣어줌. 
-c  : 일치하는 패턴을 갖고 있는 행의 수 만을 출력함. 
-l  : 일치하는 행이 있는 화일의 화일명만을 복귀개행으로 구별시켜 출력하는데, 화일내에 패턴이 몇 개나 포함되어 있어도 화일명은 한 개밖에 출력하지 않음. 
-n  : 각 행의 선두에 화일내의 행번호를 넣음.(1 라인은 1임) 
-i  : 비교시 소문자와 대문자의 차이를 무시 
-v  : 일치하는 행을 제외한 모든행을 출력. 

file
파일이 어떤 형태의 파일인지 알아낸다.
$ file [option1][option2] file
-c  : 매직 파일의 파생된 형태를 보여준다
-z  : 압축되어 있는 파일의 형태를 검사
-l  : 뒤따르는 심볼릭 링크를 야기 시킴
-f 파일명 : 검사한 파일에 대해 리포트를 만들 파일의 이름을 지정
-m 파일명 : 파일의 형태를 결정하는 데에 사용되는 매직 파일을 정함
file < test > test.out : test 파일을 입력으로 받아서 file 명령을 실행하고 test.out에 출력 
  file test.c : test.c라는 파일의 형태를 출력

find
원하는 특정 파일이나 디렉토리를 탐색하여 찾는다.
$ find path_list expression

Expressions
-name 파일명 : 찾고자 하는 파일의 이름을 정한다. 와일드 카드도 가능하다.
-perm 모드 : 파일권한(permission)이 일치되는 것을 찾는다. 원하는 권한은 ls로 볼 수있는 형태와 같이 지정한다.
-type ? : 형태가 같은 파일을 찾는다. 물음표(?) 부분에 디렉토리는 d, 파이프는 p, 심볼릭 링크는 l, 소켓은 s, 블록 파일은 b, 일반 파일은 f 등의 기호를 사용한다.
-links ? : 특정 개수의 링크를 가진 파일을 찾는다. 물음표 부분에 링크의 숫자를 표기한다.
-size ? : 파일의 크기가 일치하는 것을 탐색한다. 파일 크기는 블록단위로 물음표 부분에 지정한다. 한 블록은 512바이트로 내정되어 있지만 블록 숫자 뒤에 단위로 k자를 붙이면 1키로바이트 크기의 블록 숫자로 간주된다.
-user 사용자 : 파일 사용자의 ID에 따라서 검색한다. 로그인 이름이나 번호 모두가 가능하다.
-atime ? : 최근 며칠내에 엑세스한 파일을 검색한다. 날짜수는 ?에 명시한다.
-exec 명령 : 원하는 검색 조건에 맞는 파일을 찾으면 명시된 명령을 실행한다. 명령의 끝은 \;을 사용하여 끝낸다. find가 검색해낸 파일의 이름을 인수로 사용하고 싶다면 그 위치에 {}를 사용한다.
-newer 파일 : 어떤 파일보다 최근에 갱신된 모든 파일을 검색한다.
-cpio device : 현재의 화일은 cpio(1)의 문법(5120byte 레코드)으로 장치에 써넣는다 
-ctime n : 화일이 n 날짜내에 변경되면 참 
-group gname: 화일에 gname에 포함되어 있으면 참 
-mtime n : 화일이 n 날짜 이내에 수정되면 참 
-ok cmd : 명령어 라인을 의문부호를 선두에 부과하여 화면에 출력하며 만약 사용자가 y를 칠 경우에만 실행 가능 
find: 사용자가 지정한 특정 범위에 해당하는 모든 파일을 검색 
  # find / -name test1.c -print ; 최상위 루트 디렉토리부터 검색하여 검색된 파일을 한 행에 하나씩 표준 출력 
  # find . -name test1.c -print ; 현제의 작업 디렉토리에서 검색 
  # find / -size +1000 -print ; 최상위 루트에서 크기가 1000블록 이상인 파일 검색 
  # find . -size -1000 -print ; 현 디렉토리에서 크기가 1000블록 이하인 파일 검색 
  # find . -mtime +10 -print ; 10일 이전에 수정된 파일 검색 
  # find . -mtime -10 exec rm {} \: ; 10일 이내에 수정한 파일을 검색하여 모두 지운다 

finger
시스템 상의 사용자들에 대한 정보를 보여준다.
특정 사용자에 대한 정보를 알려면 finger username(또는 사용자가 다른 컴퓨터에 있으면 finger username@domain)을 입력한다.
$ finger [option] [user]
-s  : 사용자의 로그온 이름, 실제이름, 터미널 이름, 로그온 시간 등등을 보인다.
-l  : -s 옵션 정보에 몇 가지를 추가하여, 여러 줄에 걸쳐서 보여준다.
-p  : -l 옵션 정보에서 .plan과 .project 파일을 보이지 않는다.

foreground : 하나의 명령이 실행되어 결과를 출력할때까지 다른 명령을 수행 할 수 없다 

free
메모리의 사용상태와 남은 상태, 버퍼의 상태등을 보여줌

fsck
파일 시스템의 완전한 상태를 유지하고 있는가를 검사하고, 잘못된 것은 수정한다.
$ fsck [option] [file system]
-f  : 빠른 속도로 블록과 크기 및 자유리스트를 점검
-n  : fsck 명령 수행중에 모든 질문에 대해 no라 응답한다.
-y  : fsck 명령 수행중에 모든 질문에 대해 yes라 응답한다.
-a  : 검사도중 발견된 에러를 자동적으로 복구한다.
-r  : 검사도중 에러가 발견되면 복구할 것인가를 물어온다. 이것은 하위 호환성을 위한 것으로서 사실상은 사용되지 않는다.
-s  : 병렬적인 방법이 아니라 순차적인 방법으로 검색한다.
-V  : 검색중 각종 정보를 자세하게 보여준다.
-N  : 실제로 검사 작업을 하지는 않도록 한다.


grep
파일 중에서 어떠한 패턴을 검색합니다.
$ grep [option] expression [file]
-A  : [숫자] 라인에서 패턴과 매치되는 문자열을 찾아서 그 이상의 라인을 전부 보여줍니다.
-B  : [숫자] 라인에서 패턴과 매치되는 문장열을 찾아서 그 이하의 라인을 전부 보여줍니다.
-b  : 매치되는 라인과 그 크기(bite)를 출력합니다.
-c  : 매치되는 개수를 출력합니다.
-f  : 파일로부터 패턴을 입력받아 들입니다.
-n  : 매치되는 라인과 그 라인수를 출력합니다.
-v  : 매치되지 않는 라인을 출력합니다.
-w  : 주어진 단어와 완전히 매치되는 라인을 출력합니다.
-l  : 매치되는 내용이 있는 파일의 이름만을 표시한다.
-h  : 매치되는 내용을 찾은 파일의 이름을 표시하지 않는다.
-i  : 대소문자 구분을 하지 않는다.
-e expression : 표현이 하이픈 문자로 시작될 때 사용한다.
-f file  : 규칙적인 식(grep) 또는 리스트열(fgrep)이 화일로부터 취한다 
-s  : 읽지못하는 화일이거나 존재하지 않는 화일에 대한 에러 메세지 출력을 억제 
grep [option] 형태 [화일명] -- 정규식을 이용 패턴 지정 
  # grep -i tom sample.c -- sample.c 라는 파일에서 tom 이라는 문자열을 대소문자 구분 없이 검색 
  # grep -n tom sample -- 행 번호와 함께 출력 
  # grep -i "tom is" sample -- 공백은 " "로 표기 
  # grep -v tom sample --tom이라는 형태를 포함하지 않는 행을 출력 
  # cat sample 
  computer science 
  computer graphics 
  # cut -c10-17 sample -- sample 파일에서 칼럼 단위10-17을 절단 --> science/graphics 
  # cmp test1 test2 -- 서로 다른 두 파일을 비교 
  # dircmp test test -- 서로 다른 두 디렉토리 비교 

groupadd
그룹 이용자를 추가하는 명령어.

gpasswd
group의 사용자나 관리자를 추가, 또는 삭제할 때 쓴다.
root또는 관리자만이 group member를 추가, 삭제할 수 있다.
$ gpasswd [-r|-R] group
$ gpasswd [-a user] group
$ gpasswd [-d user] group
$ gpasswd [-A user,...] [-M user,...] group

gzip
파일 압축(확장자 .gz, .z 형태의 압축파일 생성)
$ gzip [파일명] : 압축시 
$ gzip -d [파일명] : 해제시 
gzip은 tar파일을 압축하는데 사용하는 명령어로 1단계에서 9단계로 압축률을 조정할 수 있다. 6단계를 사용하면 적절한 압축률로 압축할 수 있고 압축하는데 시간을 줄일 수도 있다.

halt
신속하게 system을 정지시키는 명령어 

hd
16진수로 파일을 덤퍼하는 명령어(od참조)
$ hd [-bcdox] [file] [[+[x]] offset [.] [b]] 

head
파일의 처음 n개의 내용을 보고자 할때 사용하는 명령

help
system 명령어에 대한 설명과 메시지에 대한 정보를 On-line 으로 제공
$ help [args]

history
작업 내역을 보여줌

hostname
현재 설정되어 있는 호스트의 이름을 표시하거나 변경한다.
$ hostname [name of host]

id
시스템에 등록된 ID를 확인한다.
$ id [option]
-g  : 그룹 ID만을 출력한다.
-G  : 추가 그룹들만을 출력한다.
-n  : ID 번호대신 이름으로 출력한다.
-r  : 실제 사용자나 그룹 ID를 출력한다. 다른 옵션과 함께 사용한다.
-u  : 사용자의 ID만을 출력한다.

ifconfig
네트워크 정보 표시
$ ifconfig [네트워크명]

ipcs
process 상호간의 통신에 대한 상태를 출력하는 명령어
$ ipcs [option]
-c  : 사용자의 로그인 명과 그룹명을 출력 
-o  : 사용 상황 상태에 대한 정보를 출력 
-p  : 프로세서 번호에 대한 정보를 출력 
-q  : 수행중인 메세지 큐(Queue)에 대한 정보를 출력 
-t  : 시간에 대한 정보를 출력 

ispell
영어 단어의 철자를 확인
$ ispell [option] [file(s)]
파일 이름을 써주면 해당 파일의 단어를 검사하며, 파일 이름없이 실행시키면 표준 입력의 단어를 체크합니다. 해당하는 단어가 없을 때는 비슷한 단어들의 리스트를 보여줍니다. 

install
파일을 갱신하고 이진 파일로써 인스톨하기 위해 makefile에서 종종 사용되는 유틸리티

jobs
현 터미널에서 수행된 작업들을 간략하게 나열해 준다.
$ jobs [-lnprs] [jobspec ...] or jobs -x command [args]
-l  : 프로세서 번호를 추가해서 보여준다.

jobs : 백그라운드로 수행중인 모든 프로세서의 상태 출력 

join
두 개의 정렬된 파일을 하나로 수평 병합한다.
$ jobs [option] [file1] [file2]
-an  : 첫 번째나 두 번째 파일로부터 일치하지 않는 것도 처리, n은 1이나 2
-e 문자열 : 비어 있는 필드는 문자열로 대체
-j n m : 파일 n의 m번째 필드를 두 파일에 병합
-o file : 명시된 파일의 형태에 따라서 출력을 만듬
-t 문자 : 필드 구분 as자를 정한다. 기본적으로 공백, 탭, 개행 문자
-v file : file1이나 file2의 짝이 연결되지 않는 행을 지정된 파일로 출력

joe
emacs에 기초한 텍스트 에디터

kernel; 생성되는 프로세스마다 PCB 부여하고 관리 

kill
프로세스를 강제 종료하는 명령어
$ kill [-signal number] process id
$ kill -l : 시그널 종류를 나열한다. 시그널의 종류는 시그널 번호 순서대로 이름으로 나열한다.
1 hang up     2 인터럽터   3 정지
4 정확하지 않는 명령    5 trace trap   6 IOT 
7 EMT    8 부도소수점 expression 발생  9 강제 종료
10 버스 에러     11 세그먼트 위배  12 bad system 콜 
13 읽는 사람없이 파이프에 써 넣음  14 경보 신호    15 Software 종료 
kill [번호] -- 프러세서 강제 종료 명령어 
  * 강제 종료가 안될 경우 -9옵션을 사용 %kill -9 1239

killall
system내에 활동중인 모든 프로세서를 강제로 종료하는 명령어

last
시스템에 마지막으로 접근한 사용자를 표시
$ last [option]
-f  : 파일명을 참조하여 출력합니다.
-t  : tty로 로그인한 터미널을 추적합니다.
-v  : 로그인한 연도를 추가해서 출력합니다.

less
more와 유사하게 페이지 단위로 문서를 보여준다. 문서의 앞으로 이동하는 것이 가능
$ less [option] file
-?  : less에서 사용할 수 있는 명령들에 대한 도움말을 제공한다. 이 옵션이 사용되면 다른 인수는 무시되고, 도움말 화면을 보여준다.
-a  : 마지막 라인이 화면에 출력되고 나서 탐색을 시작한다.
-c  : 필요할 때 전체 화면은 다시 갱신한다.
-C  : -c 옵션과 같지만 갱신할 때 화면 전체를 지우고 시작한다.
-e  : 두 번째로  파일의 끝에 도달하면 자동적으로 종료한다.
-E  : 파일의 끝에 도달하기만 하면 자동적으로 종료한다.
-i  : 대소문자를 구분하여 탐색한다.
-n   : 행번호를 추가한다.
-q  : 특정 에러가 발생하지 않으면 아무 소리도 내지 않고 조용히 동작한다.
-Q  : 결코 아무 소리도 내지 않는다.
-s  : 연속되는 공백 라인은 하나의 행으로 처리한다.
-x 숫자 : 수치를 지정해서 탭 간격을 조정한다. 기본값은 8이다.

link / unlink
file 및 directory 링크 / 링크해제  명령
$ (un)link file1 file2 

ln
실제 file을 file name에 연결시키는 명령
$ ln [-s] file_name1 file_name2
$ ln file_name(s) directory
-s  : 하드 링크 대신 심볼릭 링크를 만듬
ln test1 test2 --- test1과 test2라는 2개의 파일을 연결 (unlink ; 연결 해제) 

locate
저장 위치를 찾아줌

login / logout
자신을 식별하고 시스템에 대한 액서스를 얻기 위해 사용하는 명령
$ logiin [option] ID
-f  : 뒤의 사용자명으로 로그인
-g  : 뒤의 그룹사용자명으로 로그인

longname
현재 시스템에서 자신이 사용하는 로그온 이름을 보여줌

lp
특정 file / 정보를 프린터로 출력하는 명령어
$ lp [options] files 
-c  : 프린터가 끝나기전에 화일 변경이 가능하도록 프린트할 화일을 복사 
-d dest : 프린터 또는 프린터 클라스를 dest로 지정 
-m  : 프린트 후 전자우편을 보낸다 
-n number : 프린트 할 매수를 지정 
-s  : 메세지 출력을 억제 
-w  : 프린트 후 사용자의 단말장치에 메세지를 보낸다 

lpadmin
스풀 프린터 시스템 구축 명령어
$ lpadmin [options]
-d dest : 기존 dest를 신규 시스템의 생략시 수신자로 한다

lpstat
출력되는 라인 프린터의 상태에 대한 정보를 화면에 나타내는 명령어
$ lpstat [option]
-a list  : 프린터나 클라스의 처리 상태 출력 
-c list  : 클라스명과 멤버 출력 이때 list는 프린터명 또는 클라스명의 리스트 
-d  : lp에 대한 system을 생략시 주소를 출력 
-o list : 출력 request의 상태 출력 이때는 프린터명,클라스명,request id 리스트 
-p list : 프린터 상태 출력 이때 리스트는 프린터명 
-r  : 라인 프린터 scheduler 상태 출력 
-t  : 프린터의 모든 상태 출력 

lpstate : 프린터의 현제 상태 (활성화: enable, 비활성화: disable) 
  * lp -c temp.c ; 내용이 변경되어도 문제가 지속되지 않도록미리 출력될 파일을 복사 
  * lp -n7 /etc/lp/temp ; 7장 프린트 
  * lp -m temp.c ; 출력이 끝난후 사용자에게 전자우편을 보냄 
  * lp -t"chon bing hee" test.out ; chon bong hee라는 표제를 달아 줌 

ls
directory의 내용을 화면에 출력하는 명령어
$ ls [option] file..
-a  : .file을 포함한 전 entry를 출력 
-A  : -a option과 유사하지만 .또는 ..을 포함하는 화일은 출력 억제 
-c  : 마지막 변경된 i-node의 시간을 출력 
-C  : 멀티칼럼으로 출력하며 디폴트로는 CRT에 출력 
-d  : directory명만 출력하며 내용은 출력하지 않는다 
-D  : directory만 출력 
-f  : 인수를 directory로 해석하며 각각의 슬롯에 있는 directory 및 file명을 출력 
-F  : system에 있는 화일이 directory면 /를 실행가능한 화일이면 *를 붙인다 
-g  : 옵션 -l과 같으나 소유자명이 출력되지 않는다 
-i  : 첫 칼럼에 i-number를 출력 
-l  : 화일 및 directory 상태 정보를 long 문법으로 출력 
-m  : 스트림 문법의 출력 
-n  : 소유자명과 그룹명 대신에 UID 번호와 GID 번호가 출력되는 것을 제하고는 옵션 -l과 같다 
-g  : 비도형문자를 ?문자로 출력 
-r  : 화일명이나 수정시간을 알파벳 또는 오래된 역순으로 출력 
-R  : 발견되는 sub-directory의 내용을 순환적으로 출력 
-s  : 간접블럭을 내포하는 블럭수를 출력 
-t  : 화일명 대신에 수정된 시간으로 분류 
-u  : -t 또는 -l option으로 분류하는 중에서 최종접근 시간을 사용 
ls: 현재 위치한 디렉토리 아래에 있는 파일 및 서브디렉토리의 정보를 나열 
  - 옵션: -l: 파일의 모든 정보 출력 
  -c: 최근 변경한 시간 순서데로 출력 
  -d: 디렉토리 명만 출력 
  -F: 파일의 특성을 출력( /디렉토리 *실행화일) 
  -a: dot(.)으로 시작하는 파일의 이름을 포함한 모든 내용을 출력 

mail
사용자들간에 전자우편을 주고 받는 명령어
$ mail ID@domain_address
$ mail [-f file] [-par]
-f file  : 지정한 화일을 전자우편 화일로 한다 
-p  : 조치를 위한 prompt를 나타내지 읺고 전자우편을 출력 
-g  : 인터럽터를 건후에 종료 
-r  : 메세지를 FiFo(선입선출)방식으로 한다 

 

mailx
대화형 메시지 처리를 하는 명령어
$ mailx [option] [name ...] 
-e  : 전자우편이 있는가 없는가를 조사 
-f[file name] : mailbox 대신에 화일명에서 메세지를 읽는다 
-F  : 메세지를 최종 수신자명이 붙어 있는 화일에 기록 
-S  : subject 종속 헤드필드를 subject로 한다 
-U  : user 사용자의 mailbox를 읽어낸다 

man
원하는 명령어의 사용방법을 검색하여 보여주는 명령어
$ mailx [option] [chapter] title ...
-k  : 인수로 주어진 단어를 키워드로 사용하여, 해당 키워드가 발견되는 모든 매뉴얼의 내용을 검색
man date : 예약어나 명령어에 대한 온라인 매뉴얼 

mcd
MSDOS 시스템으로 현재 사용하는 디렉토리 장소로 이동
$ mcd [dos directory]

mcopy
MSDOS file system으로 or DOS file system의 file을 복사
$ mcopy [option] file_name1 file_name2
-t  : 텍스트 파일 복사시 CR/LF 문자를 \n 하나로 바꾼다.
-n  : 파일을 덮어쓰게 되는 경우에도 경고하지 않는다.
-v  : 자세히 안내문을 보여준다.
-m  : 파일 갱신 시간을 보존한다.

mdel
MSDOS file system에서 file을 제거
$ mdel [-v] file
-v  : 진행되는 상황을 자세히 보여줌

mdir
MSDOS directory의 목록을 보여준다.
$ mdir [-w] file
-w  : 파일 크기나 생성 날짜는 제외하고 넓은 형식으로 보여줌

mesg
teminal에 들어오는 메시지를 허가 또는 거부하는 명령어
$ mesg [n] [y] 
n  : 메세지 거부 
y  : 메세지 허가 

newgrp
현재 그룹 ID를 변경한다.

mfs
모든 file system을 mount 하는 명령어

mkdir
directory 생성
$ mkdir [-m mode] [-p] directory
-m  : 디렉토리를 만들 때 같이 사용하여 사용자 권한을 줄수 있다.
-p  : 만들 디렉토리의 상위 elfprxhflRK지 한꺼번에 만든다.
mkdir : 디렉토리 생성 명령어 (%mkdir [option] [directory name] 

mknod
특수화일을 위해 directory와 이에 i-node를 만드는 명령어
$ mknod file [b] [c] major minor
b  : 특수화일이 블럭형 
c  : 특수화일이 문자형 
major  : 주장치 번호 
minor  : 부장치 번호 

mkswap
swap 공간 생성

more
한 화면씩 출력을 보여주는 유틸리티
$ more [ -ncdflspu ][ +줄번호 ][ 파일이름(들) ]
-n  : 여기서 n은 숫자를 의미하여, 숫자는 출력 윈도우의 행수를 지정한다.
-c  : 위에서부터 한 행씩 지운 후 한 행씩 출력한다. 보통은 화면 전체를 지운 후 각 행을 출력하기 시작한다. 특정한 터미널을 위해 사용한다.
-d  : 스페이스나 q 키를 누르라는 프롬프트를 출력한다.
-f  : 화면의 행이 아닌 논리적인 행 수를 계산한다. 보통은 긴 칼럼의 행은 화면에서 행바꿈을 하여 새로운 행으로 계산된다. -f 옵션을 사용하면 이러한 행은 계산하지 않는다.
-s  : 여러 개의 빈 공백행은 하나로 취급한다.
-p  : 스크롤하지 않는다. 대신 화면을 지우고 출력한다.
-u  : 밑줄 차기를 금지한다.

설명
more 명령은 몇 가지 명령을 인식할 수 있다. 스페이스 바를 누르는 것을 포함해서 다음과 같은 조작을 하는 것이 가능하다.
■ <return> : 한 줄만 스크롤된다.
■ D        : 반 페이지만 뒤로 이동한다.
■ <space> : 한 페이지만 뒤로 이동한다.
■ B  : 한 페이지 앞으로 이동한다.
■ H  : 도움말을 제공한다.
■ V  : vi 에디터를 부른다. 에디터를 종료하면 원 위치로 돌아간다.
■ Q  : more 를 종료한다.

more [file name] : 한 번에 한 화면씩 파일의 내용을 표준 출력 
  -내용을 보지 않고 종료시 q 나 Q 키를 누른다 

mount
다른 파티션의 디스크나 물리적으로 다른 rldr 장치를 파일 시스템으로 연결
$ mount [option] 장치명 디렉토리
-v  : 마운트 작업을 수행하면서 자세한 정보를 출력한다.
-w  : 마운트되는 파일 시스템을 읽기와 쓰기가 가능하도록 한다.
-r  : 마운트되는 파일 시스템이 읽기 동작만 가능하도록 한다.
-n  : 마운트 정보가 기록되는 /etc/rntab 파일에 정보를 기록하지 않는다.
-a  : /etc/fstab 파일에 있는 모든 파일 시스템을 마운트하도록 한다.
-t 형태 : 마운트되는 파일 시스템의 형태를 지정한다.
mountall
여러개의 file system을 mount하는 명령어
$ mountall [-] file system
$ mountall [-k]
-  : 입력되는 데이타가 표준입력 
-k  : 화일을 open시키고 프로세서를 찾은 다음 SIGKILL 시그널을 보낸다 

mv
파일의 위치를 이동하거나 파일의 이름을 바꾸어 준다.
$ mv [ -fi ] 파일명1 파일명2
$ mv [ -fi ] 파일명(들) 디렉토리명
-f  : 같은 이름의 파일이 존재하고 쓰기 권한이 금지되어 있더라도 물어 보지 않고 덮어쓰기를 해버린다. 이런 경우 이 옵션을 사용하지 않으면 사용자에게 다시 확인을 할 것이다.
-i  : 파일을 덮어쓰기 전에 사용자에게 확인한다.
mv [file name1] [file name2] --file name1을 file name2로 이름 변경 
mv [file1] [file2] [directory1] --file1, file2를 directory1으로 이동 
mv [directory1] [directory2] --directory1의 모든 내용을 directory2로 이동 
  **명령어 cp, mv, rm에서 option -i는 사용자에게 여부를 묻는 옵션입니다 

mvdir
file system 내에서 directory 변경을 하는 명령어
$ mvdir [oldname] [newname]

nice
프로세스의 순위를 변경하는 명령어
$ nice command -n XX
nice값은 -20에서 19까지 있는데, 값이 작을수록 우선 순위가 높습니다. -n옵션을 쓰기 않으면 디폴트로 10이 쓰입니다. 일반 유저는 nice값을 증가시킬 수밖에 없지만 root는 nice값을 감소시켜 우선 순위를 높을 수도 있습니다.　　              
nice [-정수값:1~39 , 20으로 설정] 명령어 -->우선 순위 변경 명령어 
  정수값이 높을수록 우선 순위가 낮다 (nice -10 cc -o test test1.c) 

nl [file name] : 지정한 파일의 내용을 츨력할 때 맨 앞에 행 번호를 이어서 출력 

nohup cc -o sample1 sample1.c & 1132[PID번호] 
     백그라운드로 실행, 로그 아웃이나 중지 신호후에도 프로세서의 수행 계속 
 
nslookup
네임 서버를 조회한다.
$ nslookup [option] [host or IP Address] [name server]
-q=A  : IP Address 
-q=MX : 메일서버 확인
-q=NS : 네임서버 확인
-q=CNAME : 호스트의 앨리어스
-q=PTR : 호스트 또는 포인터명
-q=SOA : Statt of Authority 정보

od
8, 10, 16진 또는 파일의 ASCII 덤프를 만들기 위한 명령어
$ od [option] file
-b  : 바이트를 8진수로 출력
-c  : 바이트를 아스키 문자로 출력
-x  : 바이트를 16진수 워드 단위로 출력

pack test.c (파일 압축) ---> unpack test.c.z 

page [option] [file name] : 한 번에 한 화면씩 파일의 내용을 표준출력(=== %pg) 

passwd
자신의 패스워드를 관리하는 명령어
$ passwd [user]
암호화 되어 /etc/passwd 파일에 놓여집니다.
암호는 최소한 6자 이상이어야 합니다(8자 이상 권장).
암호는 구두점 기호와 숫자뿐만 아니라 대소문자를 모두 포함해도 됩니다.

paste
하나 혹은 그 이상의 파일로부터 칼럼 형태의 출력을 만든다. cut과 함께 사용
$ paste [-s] [-d 구분문자] file_name(s)
-s  : 각 file을 순회하면서 paste를 수행한다.
-d 구분문자 : 어떠한 문자로 칼럼을 구분하는지 지정. 기본값은 탭 문자

pico
UNIX용 에디터

pine
PINE 4.10   MAIN MENU                            Folder: INBOX  19 Messages

           ?     HELP        -  Get help using Pine
           C     COMPOSE MESSAGE  -  Compose and send a message
           I     MESSAGE INDEX -  View messages in current folder
           L     FOLDER LIST         -  Select a folder to view
           A     ADDRESS BOOK       -  Update address book
           S     SETUP               -  Configure Pine Options
           Q     QUIT                -  Leave the Pine program
     Copyright 1989-1999.  PINE is a trademark of the University of Washington.
                    [Folder "INBOX" opened with 19 messages]
? Help                     P PrevCmd                 R RelNotes
O OTHER CMDS > [ListFldrs] N NextCmd                 K KBLock
메일을 주고 받을 수 있는 명령

ping
자신의 네트워크나 다른 네트워크가 통신이 잘되고 있는지 점검함
$ ping hostname

ps
프로세서들의 상태를 점검하는 명령어
$ ps [options]
-l  : 자세한 형태의 정보를 출력한다.
-u  : 각 프로세서의 사용자 이름과 시작 시간을 보여준다.
-j  : 작업 중심 형태로 출력한다.
-s  : 시그널 중심 형태로 출력한다.
-v  : 가상 메모리 중심 형태로 출력한다.
-m  : 메모리 정보를 출력한다.
-a  : 다른 사용자들의 프로세서도 보여준다.
-x  : 로그인 상태에 있는 동안 아직 완료되지 않은 프로세서들을 보여준다. 유닉스 시스템은 사용자가 로그아웃하고 난 후에도 임의의 프로세서가 계속 동작하게 할 수 있다. 그러면 그 프로세서는 자신을 실행시킨 셸이 없이도 계속 자신의 일을 수행한다. 이러한 프로세서는 일반적인 ps 명령으로 확인할 수 없다. 이때 -x 옵션을 사용하면 자신의 터미널이 없는 프로세서들을 확인할 수 있다.
-S  : 차일드(child) CPU 시간과 메모리 페이지 결함(fault) 정보를 추가 한다.
-c  : 커널 task_structure로 부터 명령 이름을 보여준다.
-e  : 환경을 보여준다.
-w  : 긴(wide) 형태로 출력한다. 한 행 안에 출력이 잘리지 않는다.
-h  : 헤더를 출력하지 않는다.
-r  : 현재 실행중인 프로세서를 보여준다.
-n  : USER 와 WCHAN 을 위해 수치 출력을 지원한다.

설명
기본적으로 ps는 현재 명령이 내려지는 셸에서 만들어진 프로세서들의 목록만을 보여준다. ps는 자신이 실행되는 당시, 현재의 셸에 의해서 수행된 프로세서들을 검사하고 보고한다는 점을 생각하자. 그러면 ps의 출력결과 리스트에 ps 자신이 있는 이유를 쉽게 이해할 수 있을 것이다. 각 필드의 의미는 다음과 같다.

  COMMAND : 명령어의 이름
  PID  : 프로세서 ID, 각 프로세서를 구분하기 위한 고유의 ID
  RSS  : 프로세서에 의해 사용되는 실제 메모리의 용량(K byte 단위)
  USER : 프로세서를 실행시킨 소유자의 계정을 보여준다.
  SZ  : 프로세서의 자료와 스텍 크기의 (K byte 단위)
  TIME : 현재까지 사용된 CPU의 시간(분,초)
  TT  : 프로세서의 제어 터미널(t3=/dev/tty3)
  %CPU : 마지막 분동안 프로세서가 사용한 CPU시간의 백분율
  START : 프로세서가 시작된 시간
  STAT : 프로세서의 상태

이중 STAT 필드는 몇 가지의 부호를 사용해서 프로세서의 상태를 표시하고 있다. 그것들을 정리해 보면 다음과 같다.

  P  : 수행 가능/수행중
  T  : 일시 정지
  D  : 디스크 입출력 대기 같은 인터럽트할 수 없는 대기상태
  S  : 20초 미만의 짧게 잠듦(sleep)
  I  : 20초 이상의 길게 잠듦
  Z  : 좀비(zombi) 프로세서 

좀비(zomb) 상태라는 것은 프로세서가 사라질 때 시그널 처리의 문제로 완전히 소멸되지 못한 상태를 말한다.
ps -l --프로세스에 관한 모든 상태 정보 출력 
  ps -e --현제 실행중인 모든 프로세스에 관한 정보 출력 
  ps ps -t 00 --지정된 터미널에서 실행중인 프로세스에 관한 정보 출력 
pstree
프로세서의 트리구조를 출력한다.

pwd
현재 작업하는 디렉토리를 알기 위해서 pwd 명령을 사용한다.
print working directory, 현재 작업 Directory를 출력한다.
pwd : 현제 작업 디렉토리 출력 명령어

quota
계정에 할당된 사용량을 확인한다.
$ quota [-vq] [[-ug] | -u[ user] | -g[ group]]

quit
대화식 모드에서 떠남

reboot
system을 재부팅
$ reboot [-q]
-q  : 현재의 프로세서들을 종료시키지 않고, 부팅 동작만을 수행한다. 이 옵션을 사용하면 더 빠르게 리부팅할 수 있다. 다시 부팅한 기록은 로그 파일인 /var/adm/wtmp에 기록된다. 

rcp
컴퓨터 사이에서 file을 복사할 때 사용된다.
$ rcp [option] file_name1 file_name2
$ rcp [option] file(s) directory
-q  : 현재의 프로세서들을 종료시키지 않고, 부팅 동작만을 수행한다. 이 옵션을 사용하면 더 빠르게 리부팅할 수 있다. 다시 부팅한 기록은 로그 파일인 /var/adm/wtmp에 기록된다. 
-r  : 하위 디렉토리까지 재귀적으로 모두 복사한다. 
-p  : 파일의 시간과 모드를 보존한다.
-k  : kerberos ticktets을 요구한다. 
-x  : 복사되는 모든 데이터에 암호화 과정을 거친다. 

rfd:디스켓, rct:카트리지테이프, rmt: 테이프) 백업 및 복사에 관한 명령어 하드 ----> 디스켓 
  Non-preemptive(비선점) ; 커널 모드 
  # tar -cvf /dev/rfd0c test1 
  (c: 저장되는 파일들이 디스크의 처음부터 기록, v:기록되는 화일명 화면 출력) 
  # tar -tvf /dev/rfd0c --- 디스켓의 파일 목록 확인 
  디스켓 ----> 하드 
  #  tar -xvf /dev/rfd0c test1 --- 지정한 파일 복원  
  동일한 하드 ---> %tar -cvf test1.tar test1 
  test.c.Z (파일 생성) --- >zcat test.c.Z (파일 보기) 
  touch : 내용이 없는 빈 파일을 생성, 이미 생성된 파일의 수정 시간 갱신 
  # touch [option] [시간] [파일명] 







rm
file을 지우는 명령
$ rm [option] file_name
-f  : 보통 지울 수 있는 권한이 없으면 안되지만, 이 옵션을 사용하면 성가신 작업을 하지 않고서도 강제로 파일을 지울 수 있다.
-i  : 파일을 지울 것인가 다시 물어본다. 지우기를 원한다면 y를 누른다. 
-r  : 서브 디렉토리의 파일도 모두 재귀적으로 지운다.
-v  : 파일을 지우기 전에 파일의 이름을 나타내준다.

rmdir
원하는 directory를 제거한다.
$ rmdir [-p] directory
-p  : mkdir의 -p 옵션의 반대 동작으로 하위 디렉토리와 그 상위 디렉토리 모두를 제거할 수 있다. 이때 모든 디렉토리는 비워져 있어야 한다. 수행 후 결과가 어떻게 되었는지를 보여준다. 
rmdir : 디렉토리 삭제 명령어 
  - 옵션: rm -r test ; test의 하위디렉토리와 파일을 전부 삭제 
  - 옵션: rm -i test ; 삭제 여부를 사용자에게 물어 본다

rm test1 test2 test3 --- test1,test2,test3 파일을 삭제 
  rm -r quit --- quit 디렉토리 및 모든 내용을 삭제 

route
현재 라우터에 상태 확인 및 라우터 정보를 수정할 수 있다.
$ route add -net network address netmask device
route를 이용해서 라우터의 정보를 변경 또는 추가할 수 있다. 특히 가상 IP 설정을 할 수 있다. 즉, 한 대의 서버에 여러개의 IP를 사용할 수 있다.

rpm
레드헷 패키지 관리자
$ route add -net network address netmask device
rpm명령어는 바이너리 소프트웨어를 설치해주는 역할을 하므로써 일반사용자에게 설치의 편리성을 제공해주는 편리한 명령어이다. 설치뿐만 아니라 소프트웨어의 삭제도 간단한 명령어로 간단하게 해결해 주기 떄문에 설치된 소프트웨어의 파일을 일일이 찾아 삭제하는 수고를 덜어준다.

Running : 현제 백그라운드 수행중인 상태

sh
원래의 nunix 명령인 본 셀을 불러내는 명령어

shutdown
시스템을 종료할 때 일반적으로 사용하는 명령어
$ shutdown [ -thnrfck ] 시간 [ 메시지 ]
$ shutdown now 
-t n  : t 옵션 뒤에 n초를 명시해서, 경고 메시지를 보낸 후 n초 후에 kill 시그널을 보낸다. 
-h  : shutdown시 halt를 실행하게 한다. 
-n  : 디스크 동기화 동작의 수행을 금지한다. 이런 옵션은 보통 사용할 일이 없을 것이다. 
-r  : 시스템 종료를 완료하고 나서 다시 부팅 과정을 수행한다. 
-f  : 빠른 리부팅을 한다. 리부팅시 파일 시스템 검사를 하지 않는다. 
-c  : 이미 예약되어 있는 shutdown을 취소한다. 이 옵션을 준다면 시간 인수는 줄 수 없다. 하지만 메시지는 사용자들에게 줄 수 있다. 
-k  : 모든 동작을 제대로 수행하지만 시스템을 종료할 시간이 되면 아무 것도 하지 않는다. 보는 사람으로 하여금 '절로 누구 놀리나?'하는 말이 나오게 한다. k는 'just kidding'의 의미라고 한다. 

sleep
이름 그래로 잠자는 일 외에는 하는 일이 없다.
$ sleep 시간
시간은 초 단위의 정수 숫자이다. 전면(foreground)에서 수행된다면 사용자의 터미널은 정해진 시간만큼 잠을 잘 것이다. 물론 정해진 시간에 즉각 일어나니 안심해라. 원한다면 ^C로 흔들어 깨울 수도 있다. sleep을 사용하는 가장 좋은 예는 3장에서 본 것과 같이 다중 작업을 시행할 때이다. 

다음과 같은 확인자를 사용한다면 다른 시간 단위를 사용할 수 있다. 

S 초   m 분
h 시간   d 날짜

sort
파일 내의 단어 순서를 행 단위로 정렬하는 명령어
$ sort [option] file_name(s)
-c  : 파일이 정렬되었는지 검사한다. 그렇다면 아무런 출력도 하지 않는다. 
-m  : 특정한 파일을 병합한다. 파일은 이미 정렬되었다고 가정한다. 
-u  : 고유한 행만이 출력된다. 
-o 파일명 : 출력 파일 이름을 지정한다. 이름은 입력 파일 이름과 같을 수 있다. 
-d  : 사전(dictionary)과 같은 순서대로 정렬한다. 단어 정렬 순서에는 문자, 숫자, 공백 문자만이 사용된다. 
-f  : 대문자와 소문자를 구별하지 않는다. 
-i  : 정렬에 사용되는 문자 중 프린트될 수 없는 문자는 사용하지 않는다. 
-M  : 단어를 정렬할 때 달을 의미하는 문자를 취급한다. FEB는 JAN보다 뒤에 정렬된다. 
-n  : 숫자를 같은 문자가 아닌 정말로 숫자로 취급해서 수의 크기대로 정렬한다. 
-r  : 역순으로 정렬한다. 
-t 문자 : 단어 등 필드를 구분하는 문자를 지정한다. 탭(tab)이나 공백 문자 이외의 문자를 구분 문자로 취급하도록 한다. 
-b  : 단어의 뒤에 오는 공백 문자는 정렬 키(key) 값으로 무시하도록 한다. 

split
텍스트 file을 작은 조각으로 나눈다. 너무 커서 다루기 불편한 텍스트 문서를 나눌 때 사용
$ split -행 수 file_name [tag_name]
-행 수 : 몇 개의 행 단위로 조각을 나누는지 정한다. 

Stopped : fg로 수행되다가 ^D로 잠시 중단된 상태 

su
다른 사용자 계정으로 서브 셸을 생성한다. 잠시만 다른 사용자 계정으로 작업할 필요가 있을 때 사용한다.
$ su [-] [userID] [인수]
-  : 하이픈 (-)을 사용하면 새로운 셸로 로그인할 때 자신의 로그인 과정을 수행한다. 옵션이 주어지지 않으면 새로운 셸은 단지 셸 역할을 수행할 뿐이다. 
아무런 인수없이 su를 사용하면, 이것은 root 계정으로 로그인하기를 원하는 것으로 간주된다. 그래서 많은 사람들이 su가 'super user'를 의미하는 말로 생각하지만, 사실은 'substitute user'를 의미하는 말이다. 물론 수퍼 유저의 패스워드를 알고 있어야만 한다. 

swapon
스왑 공간 사용하기

sync
현재 시스템 디스크의 IO 버퍼에 있는 디스크 이미지를 하드 디스크로 기록한다.
$ sync
시스템을 다운시키기 전에 버퍼에 있는 이미지를 반드시 디스크로 기록해야 한다. 그렇지 않으면 디스크는 기록된 정보의 이미지와 일치하지 않는 이미지를 가지게 될지도 모른다. 사실, 이것을 사용할 경우는 극히 드물다. 왜냐하면 shutdown등의 동작을 수행하면 그들이 자동적으로 sync를 호출하기 때문이다. 

tail
문서의 끝 부분을 화면에 출력한다.
$ tail [-행수] file_name(s)
-행 수 : 출력될 행수를 지정한다.

tar
file들을 묶는 명령어
$ su [-] [userID] [인수]
주요 동작 모드 :
 -t, --list   : 아카이브의 내용물을 출력합니다
 -x, --extract, --get  : 아카이브에서 파일을 추출합니다
 -c, --create   : 새로운 아카이브를 만듭니다
 -d, --diff, --compare : 아카이브와 파일 시스템간의 차이점을 비교합니다
 -r, --append  : 아카이브 끝에 파일을 추가합니다
 -u, --update  : 아카이브 안의 것보다 새로운 파일만 추가합니다
 -A, --catenate  : 아카이브에 tar 파일을 추가합니다
     --concatenate  : -A와 같음
     --delete   : 아카이브로부터 제거합니다 (자기 테이프에선 안됨!)
 
동작 변경자:
 -W, --verify   : 아카이브를 기록한 다음 검증하도록 합니다
     --remove-files  : 아카이브에 파일을 추가한 다음 지웁니다
 -k, --keep-old-files  : 추출할 때 이미 존재하는 파일을 덮어쓰지 않습니다
 -U, --unlink-first  : 추출하기에 앞서 대상 파일을 지웁니다
     --recursive-unlink : 디렉토리를 추출하기에 앞서 그 체계를 비웁니다
 -S, --sparse   : 스파스 파일을 효율적으로 처리합니다
 -O, --to-stdout  : 표준 출력으로 파일을 추출합니다
 -G, --incremental  : 오래된 GNU 형식의 점진적 백업 파일을 처리합니다
 -g, --listed-incremental : 새로운 GNU 형식의 점진적 백업 파일을 처리합니다
     --ignore-failed-read : 읽을 수 없는 파일에 대해 영 아닌 값으로 종료하지 않습니다

장치 선택과 전환:
 -f, --file=ARCHIVE  : 아카이브 파일 또는 ARCHIVE 장치를 사용합니다
     --force-local  : 이름에 콜론이 있는 아카이브 파일도 지역 파일로 인식합니다
     --rsh-command=COMMAND: rsh 대신 원격 COMMAND를 사용합니다
 -[0-7][lmh]   : 드라이브와 기록 밀도를 지정합니다
 -M, --multi-volume  : 다중 볼륨 아카이브를 생성/출력/추출합니다
 -L, --tape-length=NUM : NUM x 1024 바이트를 쓴 뒤에 테이프를 바꿉니다
 -F, --info-script=FILE : 각 테이프의 끝에서 스크립트를 실행합니다 (-M을 포함함)
     --new-volume-script=FILE: -F FILE과 같음
     --volno-file=FILE  : FILE 안에 있는 볼륨 번호를 사용/갱신합니다

장치 블럭 설정:
 -b, --blocking-factor=BLOCK: 레코드당 BLOCK x 512 바이트
     --record-size=SIZE : 레코드당 SIZE 바이트, 512의 배수
 -i, --ignore-zeros  : 아카이브에서 영으로 된 블럭을 무시합니다 (EOF를 의미함)
 -B, --read-full-records : 읽은 것을 재블럭화합니다 (4.2BSD 파이프용으로)
정보 출력에 관한 옵션:
     --help   : 이 도움말을 인쇄하고 끝냅니다
     --version  : tar 프로그램의 버전 번호를 인쇄하고 끝냅니다
 -v, --verbose  : 처리되는 파일을 순서대로 출력합니다
     --checkpoint  : 아카이브를 읽을 동안 디렉토리 이름을 인쇄합니다
     --totals   : 아카이브를 만들 동안 쓰여진 총 바이트 수를 인쇄합니다
 -R, --block-number  : 각 메시지마다 아카이브내의 블럭 번호를 표시합니다
 -w, --interactive  : 모든 행동에 대해 확인을 요구합니다
      --confirmation  : -w와 같음
 -s, --same-order  : sort names to extract to match archive
     --preserve-order  : same as -s
     --preserve  : same as both -p and -s
 -z, --gzip, --ungzip  : filter the archive through gzip
 -Z, --compress, --uncompress: filter the archive through compress
     --use-compress-program=PROG: filter through PROG (must accept -d)

tcsh
c 셸 명령 번역기. c 셸의 확장판
$ tcsh [option] file
-T  : tenex라고 하는 특수한 기능을 수행하도록 한다. 
-V  : -v 옵션과 같지만 초기화 스크립트의 수행에도 영향을 미친다. 
나머지 옵션들은 bash셸과 같다.
tee
파이프 연결 출력을 양방향으로 나눈다.
$ tee [option] file_name(s)
-i  : 인터럽트를 무시하도록 한다. 
-a  : 지정된 파일들로 출력이 덮어쓰지 않고, 뒤에 추가되도록 한다. 

Terminated : Kill 명령을 사용해 강제로 종료된 상태 

test
file의 각종 상태를 검사하여 결과를 알려준다. 셀 스크립트 상에서 if 문이나 while 문등과 함께 사용되는게 보통이다.
$ test [expression]
Expressions
-r 파일명 : 파일이 읽기 권한이 있으면 참
-w 파일명 : 파일이 쓰기 권한이 있으면 참
-x 파일명 : 파일이 실행하기 권한이 있으면 참
-f 파일명 : 파일이 일반(regular) 파일이면 참
-d 파일명 : 파일이 디렉토리이면 참
-b 파일명 : 파일이 존재하고 블록 장치 파일이면 참
-c 파일명 : 파일이 문자 전용 파일(character special file)이면 참
-u 파일명 : 파일이 set-user-ID 플래그가 세트되어 있으면 참 
-g 파일명 : 파일이 set-group-ID 플래그가 세트되어 있으면 참
-k 파일명 : 파일이 sticky 비트가 세트되어 있으면 참
-s 파일명 : 파일의 크기가 0보다 크면 참 
-t 파일 디스크립터 : 파일 디스크립터에 해당하는 파일이 열려 있고, 터미널 장치로부터 사용되고 있으면 참, 기본 디스크립터 값은 1이다. 
-z 문자열 : 문자열의 길이가 0이면 참
-n 문자열 : 문자열의 길이가 t 이상이면 참
-문자열 1 = 문자열2 : 문자열1과 문자열2가 같으면 참
-문자열 1 != 문자열2 : 문자열1과 문자열2가 다르면 참
-문자열 : 문자열이 널(null)이 아니면 참, 널 문자열이면 거짓
-정수1-eq정수2 : 두 개의 정수1과 정수2가 같으면 참
-정수1-ne정수2 : 두 정수가 다르면 참
-정수1-gt정수2 : 정수1이 정수2 보다 크면 참
-정수1-ge정수2 : 정수1이 정수2 보다 크거나 같으면 참

이외에도 -lt(작으면) -le(작거나 같으면), !(논리부정), -a(AND), -o(OR) 등과 같은 표현을 사용할 수 있으며, 괄호를 사용할 수도 있다.

time
프로그램이 수행되는 시간을 측정한다.

설명
time의 인수로 측정하고자 하는 명령을 준다. time은 세 가지 다른 형태의 시간 측정 결과를 보고한다. 실제로 얼마만큼의 시간이 걸렸는가 하는 real 커널이 사용한 시간을 제외하고 CPU에서 소비된 시간을 나타내는 user그리고 실제로 얼마만큼의 커널 시간을 할애했는가 하는 sys시간이 있다. sys+user 시간이 실제로 작업에 할애된 시간이며, real 값에서 sys+user 값을 뺀 결과값은 다른 프로세서 처리에 할당된 시간이다. 

 
top
프로세서의 상태를 실시간으로 확인한다.

설명
top명령어는 현재 시스템의 메모리의 상태를 실시간으로 점검할 수 있는 장점이 있다. 현재 사용중인 프로세서와 사용중인 메모리 및 스왑의 양이 출력된다. 시스템을 주의 관찰해야 되는 경우에 사용하면 상당히 도움이 된다. 

touch
파일의 엑세스 시간이나 갱신 시간을 수정한다.
$ touch [option] file
$ [-acm] MMDDhhmm[YY] file (obsolescent)
-a   : change only the access time
-c   : do not create any files
-d, --date=STRING : parse STRING and use it instead of current time
-f    : (ignored)
-m   : change only the modification time
-r, --reference=FILE : use this file's times instead of current time
-t STAMP  : use [[CC]YY]MMDDhhmm[.ss] instead of current time
    --time=WORD : access -a, atime -a, mtime -m, modify -m, use -a
    --help  : display this help and exit
    --version  : output version information and exit

tr
특정한 문자들을 다른 문자로 변경한다. redirection과 함께 사용
$ tr [option] 변경할문자 변경문자
-c  : 파일의 모든 내용을 보이지 않고 바꾸는 작업만 보여준다.
-d  : 파일에서 변경할 문자를 제거한다. 

설명
문자 표현시 백슬래쉬 문자 뒤에 8진법 숫자를 써서 문자 코드를 표현할 수 있다. 또한  [c1-c2]와 같은 하이픈 표현으로 문자의 범위를 지정할 수 있으며 [c*n]과 같은 방법으로 n 만큼의 문자 반복을 표현할 수도 있다. 변경할 문자의 변경 문자의 개수는 같아야 한다. 

traceroute
네트웍크의 구간에 접속한 시간을 측정한다.
$ traceroute [IP Address 또는 Host]

true
셸 상에서 참의 의미를 가지는 0을 반환한다.

tty
현재 로그온 되어 있는 터미널의 장치 이름을 알려준다.
$ tty [-s]
-s  : 표준 입력이 터미널 장치인지 아닌지를 시험한다. 터미널이 표준이라면 0을 반환하며 아니면 1을 반환한다.
tty : 현재 사용하고 있는 단말 장치의 이름을 경로와 함께 표준 출력 

umask
파일을 생성할 때 현재 사용되고 있는 권한(permission)값의 마스크가 무엇인지 알려주거나 그것을 새로 지정할 때 사용된다.
$ umask [마스크]
마스크 값은 세 자리의 8진법 숫자로 구성된다. 이것을 마스크라고 부르는 이유는 마스크 값의 각 비트가 들어오는 값을 걸러내는 역할을 하기 때문이다. 즉 마스크 값이 0이면 권한 지정에 제한을 두지 않는다는 것이고 6이라면 읽기와 쓰기에 제한을 가한다는 의미가 되기 때문이다. 

umount
설정된 마운트 정보를 해제한다.
$ umount 장치면 or mount_piont
$ umount -a
$ umount -t file_system_type
-a  : 모든 파일 시스템의 마운트 정보를 해제한다. 
-t  : 특정 형태의 파일 시스템만을 선택하여 해제된다. 옵션 뒤에는 어떤 파일 시스템을 해제할 것인지 지정한다. 

uname
시스템 이름과 다른 정보를 보여준다.
$ uname [option]
-s  : 시스템 이름을 알려준다. (기본값으로 내장)
-n  : 시스템의 노드(node) 이름을 알려준다.
-r  : 오퍼레이팅 시스템의 증명번호를 알려준다. 
-v  : 오퍼레이팅 시스템의 버전(version) 번호를 알려준다. 
-m  : 하드웨어의 이름을 알려준다. 
-a  : 모든 정보를 알려준다. -snrvm 과 같다.

uncompress
compress로 압축되어 있는 file의 압축을 푼다.
$ uncompress file_name(s)
사실상, compress의 -d 옵션을 사용하면 압축을 풀 수 있기 때문에 이 명령은 불필요하다. 하지만 옵션을 사용하는 것보다 의미있는 단어를 사용함으로 좀더 친숙하게 사용할 수 있다. uncompress는 자신이 압축 풀기 동작을 수행하는 것이 아니라 -d 옵션을 주어 compress를 호출한다. uncompress 자신의 파일 크기는 아주 적다. 
 
users
간단히 사용자들의 ID 이름만을 알고자 할때 사용한다.
 
uptime
서버 부팅시간과 현재 시간이 출력된다.
 
uundecode / uuencode
uuencode는 USENET과 같이 ASC2 코드만을 다루는 미디어를 위해 바이너리 코드를 변환한다.
uudecode는 그 반대의 동작을 수행한다.
$ uudecode file..
$ uuencode file.. 이름

사용예
$ uuencode canexe.Z canexe.Z > exemail.uu
canexe.Z 라는 파일을 인코딩 작업을 거친 후 exemail.uu라는 파일로 저장한다. 이 파일을 디코딩하면 canexe.Z라는 이름으로 파일이 만들어진다.

w
현재 시스템에 접속한 사용자들의 정보를 출력한다.
$ w [user]

wait [작업번호] --백그라운드 실행 종료 
 
wall
현재 시스템에 로그온되어 있는 모든 사용자들에게 메시지를 보낸다.
$ wall [message]
메시지는 각 사용자의 터미널에 나타나게 된다. 인수로 파일 이름이 주어지지 않으면 표준 입력으로부터 데이터를 받아들이며, ^D로 입력을 종결하고 메시지를 발송한다. 이것을 사용하려면 슈퍼 유저로 로그인되어야 한다. 사용자가 자신의 터미널을 메시지 수신 거부 상태로 만들어 놓더라도 슈퍼 유저는 그것을 무시할 수 있다. 

wc
file 내의 단어 수 등의 정보를 출력한다.
$ wc [option] file(s)
-c  : 문자(character)의 개수만을 알고 싶을 때 사용한다.
-w  : 단어(word)의 개수만을 알고 싶을 대 사용한다. 
-l  : 행(line)의 숫자를 알고 싶을 때 사용한다. 혹은 개행 문자의 개수를 알고자 할 때 사용될 수도 있다. 

whereis
문자열 또는 file을 검색한다.

which
등록된 path를 통해서 특정 프로그램을 찾는다.

who
현재의 시스템에 접속한 사용자의 이름이나 로그온 정보를 보여준다.
$ who [ -uTHqs ] [로그온 정보파일 ]
-u  : 현재 시스템에 누가 로그온되어 있는지 보여준다. 
-T  : 사용자의 터미널이 메시지를 보낼 수 있는지를 알려준다. +기호는 메시지를 쓸 수 있고, -는 그렇지 않음을 보여준다. 
-H  : 헤더 라인을 프린트한다. 
-q  : 사용자 이름과 카운트가 구분된 목록을 보여줌, 다른 옵션은 무시된다. 
-s  : 호환을 위해 포함된 옵션으로 무시된다. 
who : 유닉스 시스템에 로그인 되어 있는 사용자들에 대한 정보를 화면에 표시 

whoami
현재 접속한 계정명 확인 및 접속자의 정보를 출력한다.
$ whoami

write
사용자의 터미널 사이에 메시지를 전달한다.
$ write [user] [tty]
메시지를 전달하고자 하는 사용자의 이름을 지정한다. 만일 한 사용자의 이름으로 두 명 이상이 사용중이면 특정 터미널을 지정하여(tty) 메시지를 전달할 수 있다. write는 표준 입력 장치로 전달할 메시지를 입력받는다. 각행에서 리턴 키를 누를 때마다 메시지가 전달되며, ^D를 누르면 그만둔다. 

메시지가 수신되면 'Message from 보낸사람 터미널'등의 정보를 보여주어서 누가 어느 터미널에서 메시지를 보내는지를 알 수 있도록 한다. 보내고자 하는 사람이 로그인되어 있지 않다면 'user is not logged on이라고' 알려주며 만일 그 사람의 터미널이 메시지 수신을 거부하고 있는 상태라면 'permission denied 라는' 말을 보여준다. 그는 아마도 mesg n 명령을 사용했을 것이다. 

xdm
X-Widows상에서 login screen을 보여준다.
어떤 system은 특정 level로 가도록 지정하면 xdm을 시동시킨다(/etc/inittab를 보도록).
리눅스 부팅 스크립트에 넣어두면 리눅스를 처음 부팅할 때부터 엑스윈도우로 부팅할 수 있다.

zcat
데이터를 다른 명령에 파이프 하려는 경우 사용하는 명령어
cat 명령과 똑같이 작업하지만 입력으로 압축된 파일이 필요하다.
zcat은 파일을 압축 해제한 후 표준 출력 디바이스에 프린트한다.
zcat namelist | program1 | program2 ...